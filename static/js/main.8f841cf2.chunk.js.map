{"version":3,"sources":["rtc.js","App.js","index.js"],"names":["Config","iceServers","url","OfferOptions","offerToReceiveAudio","offerToReceiveVideo","WebRTC","this","peerConnection","RTCPeerConnection","stream","getTracks","forEach","track","addTrack","Promise","resolve","setTimeout","onicecandidate","candidate","console","log","gatherICECandidates","createOffer","offer","setLocalDescription","localDescription","setRemoteDescription","createAnswer","answer","callback","addEventListener","close","ValidAccountRe","MediaConstraints","audio","video","App","props","state","connected","signedIn","calling","accountId","receiverId","receiversKey","accountLoading","callConnected","_parseEncryptionKey","_initNear","then","setState","_accountId","localVideoRef","React","createRef","remoteVideoRef","key","localStorage","getItem","buf","Buffer","from","length","nacl","secretKeyLength","Error","keyPair","fromSecretKey","setItem","secretKey","toString","_key","publicKey","_contract","get_key","account_id","set_key","nearConfig","networkId","nodeUrl","contractName","walletUrl","keyStore","nearlib","BrowserLocalStorageKeyStore","Object","assign","deps","near","_keyStore","_nearConfig","_near","_walletConnection","getAccountId","_account","account","viewMethods","changeMethods","_updateEncryptionPublicKey","value","stateChange","toLowerCase","replace","isValidAccount","catch","e","match","requestSignIn","msg64","theirPublicKey64","theirPublicKey","publicKeyLength","nonce","Uint8Array","nonceLength","copy","box","decodedBuf","open","str","fullBuf","set","webrtc","addOnTrackListener","current","srcObject","streams","play","navigator","mediaDevices","getUserMedia","addStream","get_request","from_account_id","to_account_id","theirRequestEncoded","theirRequest","JSON","parse","decryptBox","time","Date","getTime","response","encryptBox","stringify","respond","requestTime","request","awaitingResponse","get_response","theirResponseEncoded","theirResponse","onAnswer","hangUp","pause","local","remote","content","className","htmlFor","type","receiverClass","id","placeholder","disabled","onChange","handleChange","target","onClick","initCall","ref","playsInline","muted","role","aria-hidden","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.8f841cf2.chunk.js","sourcesContent":["const Config = {\n    iceServers:[\n        {url: 'stun:stun.l.google.com:19302'},\n        {url: 'stun:stun1.l.google.com:19302'},\n        {url: 'stun:stun2.l.google.com:19302'},\n        {url: 'stun:stun3.l.google.com:19302'},\n        {url: 'stun:stun4.l.google.com:19302'},\n        {url: 'stun:stun.ekiga.net'},\n        {url: 'stun:stun.ideasip.com'},\n        {url: 'stun:stun.rixtelecom.se'},\n        {url: 'stun:stun.schlund.de'},\n        {url: 'stun:stun.stunprotocol.org:3478'},\n        {url: 'stun:stun.voiparound.com'},\n        {url: 'stun:stun.voipbuster.com'},\n        {url: 'stun:stun.voipstunt.com'},\n        {url: 'stun:stun.voxgratia.org'},\n        {url: 'stun:23.21.150.121'},\n    ]\n};\n\nconst OfferOptions = {\n    offerToReceiveAudio: 1,\n    offerToReceiveVideo: 1\n};\n\nconst ICETimeout = 1000;\n\n\nexport default class WebRTC {\n    constructor() {\n        this.peerConnection = new RTCPeerConnection(Config);\n    }\n\n    addStream(stream) {\n        stream.getTracks().forEach(track => this.peerConnection.addTrack(track, stream));\n    }\n\n    gatherICECandidates() {\n        return new Promise((resolve) => {\n            setTimeout(resolve, ICETimeout);\n            this.peerConnection.onicecandidate = (candidate) => {\n                console.log(\"candidate\", candidate);\n                // We're waiting for all ICE candidates to gather before resolving this.\n                if (candidate.candidate == null) {\n                    resolve();\n                }\n            }\n        });\n    }\n\n    async createOffer() {\n        const gatherICECandidates = this.gatherICECandidates();\n        const offer = await this.peerConnection.createOffer(OfferOptions);\n        await this.peerConnection.setLocalDescription(offer);\n        await gatherICECandidates;\n        return this.peerConnection.localDescription;\n    }\n\n    async createAnswer(offer) {\n        await this.peerConnection.setRemoteDescription(offer);\n        const gatherICECandidates = this.gatherICECandidates();\n        const answer = await this.peerConnection.createAnswer(OfferOptions);\n        await this.peerConnection.setLocalDescription(answer);\n        await gatherICECandidates;\n        return this.peerConnection.localDescription;\n    }\n\n    async onAnswer(answer) {\n        await this.peerConnection.setRemoteDescription(answer);\n    }\n\n    addOnTrackListener(callback) {\n        this.peerConnection.addEventListener('track', callback);\n    }\n\n    close() {\n        this.peerConnection.close();\n    }\n}\n","import \"./App.css\";\nimport React from 'react';\nimport * as nearlib from 'nearlib';\nimport * as nacl from \"tweetnacl\";\nimport WebRTC from './rtc.js';\n\nconst ContractName = 'webrtc-chat';\nconst MaxTimeForResponse = 60 * 1000;\nconst MinAccountIdLen = 2;\nconst MaxAccountIdLen = 64;\nconst ValidAccountRe = /^(([a-z\\d]+[-_])*[a-z\\d]+\\.)*([a-z\\d]+[-_])*[a-z\\d]+$/;\nconst MediaConstraints = {\n  audio: true,\n  video: true\n};\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      connected: false,\n      signedIn: false,\n      calling: false,\n      accountId: null,\n      receiverId: \"\",\n      receiversKey: null,\n      accountLoading: false,\n      callConnected: false,\n    };\n\n    this._parseEncryptionKey()\n    this._initNear().then(() => {\n      this.setState({\n        connected: true,\n        signedIn: !!this._accountId,\n        accountId: this._accountId,\n      })\n    })\n\n    this.localVideoRef = React.createRef();\n    this.remoteVideoRef = React.createRef();\n  }\n\n  /**\n   read private key from local storage\n   - if found, recreate the related key pair\n   - if not found, create a new key pair and save it to local storage\n   */\n  _parseEncryptionKey() {\n    const keyKey = \"enc_key:\";\n    let key = localStorage.getItem(keyKey);\n    if (key) {\n      const buf = Buffer.from(key, 'base64');\n      if (buf.length !== nacl.box.secretKeyLength) {\n        throw new Error(\"Given secret key has wrong length\");\n      }\n      key = nacl.box.keyPair.fromSecretKey(buf);\n    } else {\n      key = new nacl.box.keyPair();\n      localStorage.setItem(keyKey, Buffer.from(key.secretKey).toString('base64'));\n    }\n    this._key = key;\n  }\n\n  async _updateEncryptionPublicKey() {\n    const key = Buffer.from(this._key.publicKey).toString('base64');\n\n    const currentKey = await this._contract.get_key({account_id: this._accountId});\n    if (currentKey !== key) {\n      console.log(`Updating public encryption key to ${key}`);\n      await this._contract.set_key({key});\n    } else {\n      console.log(`Current public encryption key is up to date: ${key}`);\n    }\n  }\n\n  async _initNear() {\n    const nearConfig = {\n      networkId: 'default',\n      nodeUrl: 'https://rpc.nearprotocol.com',\n      contractName: ContractName,\n      walletUrl: 'https://wallet.nearprotocol.com',\n    };\n    const keyStore = new nearlib.keyStores.BrowserLocalStorageKeyStore();\n    const near = await nearlib.connect(Object.assign({ deps: { keyStore } }, nearConfig));\n    this._keyStore = keyStore;\n    this._nearConfig = nearConfig;\n    this._near = near;\n\n    this._walletConnection = new nearlib.WalletConnection(near, \"webrtc-chat\");\n    this._accountId = this._walletConnection.getAccountId();\n\n    if (!!this._accountId) {\n      this._account = this._walletConnection.account();\n      this._contract = new nearlib.Contract(this._account, ContractName, {\n        viewMethods: ['get_key', 'get_request', 'get_response'],\n        changeMethods: ['set_key', 'request', 'respond'],\n      });\n      await this._updateEncryptionPublicKey();\n    }\n  }\n\n  handleChange(key, value) {\n    const stateChange = {\n      [key]: value,\n    };\n    if (key === 'receiverId') {\n      value = value.toLowerCase().replace(/[^a-z0-9\\-_.]/, '');\n      stateChange[key] = value;\n      stateChange.receiversKey = null;\n      if (this.isValidAccount(value)) {\n        stateChange.accountLoading = true;\n        this._contract.get_key({account_id: value}).then((receiversKey) => {\n          if (this.state.receiverId === value) {\n            this.setState({\n              accountLoading: false,\n              receiversKey,\n            })\n          }\n        }).catch((e) => {\n          if (this.state.receiverId === value) {\n            this.setState({\n              accountLoading: false,\n            })\n          }\n        })\n      }\n    }\n    this.setState(stateChange);\n  }\n\n  isValidAccount(accountId) {\n    return accountId.length >= MinAccountIdLen &&\n        accountId.length <= MaxAccountIdLen &&\n        accountId.match(ValidAccountRe);\n  }\n\n  receiverClass() {\n    if (!this.state.receiverId || (this.isValidAccount(this.state.receiverId) && this.state.accountLoading)) {\n      return \"form-control form-control-large\";\n    } else if (this.isValidAccount(this.state.receiverId) && this.state.receiversKey) {\n      return \"form-control form-control-large is-valid\";\n    } else {\n      return \"form-control form-control-large is-invalid\";\n    }\n  }\n\n  async requestSignIn() {\n    const appTitle = 'WebRTC Chat';\n    await this._walletConnection.requestSignIn(\n        ContractName,\n        appTitle\n    )\n  }\n\n  /**\n   unbox encrypted messages with our secret key\n   @param {string} msg64 encrypted message encoded as Base64\n   @param {Uint8Array} theirPublicKey the public key to use to verify the message\n   @return {string} decoded contents of the box\n   */\n  decryptBox(msg64, theirPublicKey64) {\n    const theirPublicKey = Buffer.from(theirPublicKey64, 'base64');\n    if (theirPublicKey.length !== nacl.box.publicKeyLength) {\n      throw new Error(\"Given encryption public key is invalid.\");\n    }\n    const buf = Buffer.from(msg64, 'base64');\n    const nonce = new Uint8Array(nacl.box.nonceLength);\n    buf.copy(nonce, 0, 0, nonce.length);\n    const box = new Uint8Array(buf.length - nacl.box.nonceLength);\n    buf.copy(box, 0, nonce.length);\n    const decodedBuf = nacl.box.open(box, nonce, theirPublicKey, this._key.secretKey);\n    return Buffer.from(decodedBuf).toString()\n  }\n\n  /**\n   box an unencrypted message with their public key and sign it with our secret key\n   @param {string} str the message to wrap in a box\n   @param {Uint8Array} theirPublicKey the public key to use to encrypt the message\n   @returns {string} base64 encoded box of incoming message\n   */\n  encryptBox(str, theirPublicKey64) {\n    const theirPublicKey = Buffer.from(theirPublicKey64, 'base64');\n    if (theirPublicKey.length !== nacl.box.publicKeyLength) {\n      throw new Error(\"Given encryption public key is invalid.\");\n    }\n    const buf = Buffer.from(str);\n    const nonce = nacl.randomBytes(nacl.box.nonceLength);\n    const box = nacl.box(buf, nonce, theirPublicKey, this._key.secretKey);\n\n    const fullBuf = new Uint8Array(box.length + nacl.box.nonceLength);\n    fullBuf.set(nonce);\n    fullBuf.set(box, nacl.box.nonceLength);\n    return Buffer.from(fullBuf).toString('base64')\n  }\n\n  async initCall() {\n    const receiverId = this.state.receiverId;\n    const receiversKey = this.state.receiversKey;\n    this.setState({\n      calling: true,\n    });\n\n    this.webrtc = new WebRTC();\n    this.webrtc.addOnTrackListener((e) => {\n      console.log(\"got remote streams\", e);\n      if (this.remoteVideoRef.current.srcObject !== e.streams[0]) {\n        this.remoteVideoRef.current.srcObject = e.streams[0];\n        this.remoteVideoRef.current.play();\n      }\n    });\n\n    const stream = await navigator.mediaDevices.getUserMedia(MediaConstraints);\n    this.localVideoRef.current.srcObject = stream;\n    this.localVideoRef.current.play();\n\n    this.webrtc.addStream(stream);\n\n    try {\n      // First check if they called us first\n      const theirRequestEncoded = await this._contract.get_request({\n        from_account_id: receiverId,\n        to_account_id: this._accountId,\n      });\n\n      if (theirRequestEncoded) {\n        // decoding\n        const theirRequest = JSON.parse(this.decryptBox(theirRequestEncoded, receiversKey));\n        console.log(theirRequest);\n        if (theirRequest) {\n          const theirTime = theirRequest.time || 0;\n          if (theirTime + MaxTimeForResponse > new Date().getTime()) {\n            const offer = theirRequest.offer;\n            console.log(\"Remote offer: \", offer);\n            const answer = await this.webrtc.createAnswer(offer);\n            console.log(\"Local answer: \", answer);\n            // Publishing answer\n            const response = this.encryptBox(JSON.stringify({\n              answer,\n              time: new Date().getTime(),\n            }), receiversKey);\n            await this._contract.respond({\n              to_account_id: receiverId,\n              response,\n            });\n            this.setState({\n              callConnected: true,\n            })\n            return;\n          }\n        }\n      }\n    } catch (e) {\n      console.log(\"Failed to parse request\", e);\n    }\n\n    // Sending a new request\n    const offer = await this.webrtc.createOffer();\n    console.log(\"Local offer: \", offer);\n    const requestTime = new Date().getTime();\n    const request = this.encryptBox(JSON.stringify({\n      offer,\n      time: requestTime,\n    }), receiversKey);\n    await this._contract.request({\n      to_account_id: receiverId,\n      request,\n    });\n\n    this.setState({\n      awaitingResponse: true,\n    })\n\n    // Sent request, now need to check for the answer.\n    while (this.state.calling && requestTime + MaxTimeForResponse > new Date().getTime()) {\n      try {\n        const theirResponseEncoded = await this._contract.get_response({\n          from_account_id: this._accountId,\n          to_account_id: receiverId,\n        });\n\n        if (theirResponseEncoded) {\n          // decoding\n          const theirResponse = JSON.parse(this.decryptBox(theirResponseEncoded, receiversKey));\n          console.log(theirResponse);\n          if (theirResponse) {\n            const answer = theirResponse.answer;\n            console.log(\"Remote answer: \", answer);\n            await this.webrtc.onAnswer(answer);\n            this.setState({\n              callConnected: true,\n              awaitingResponse: false,\n            })\n            return;\n          }\n        }\n      } catch (e) {\n        console.log(\"Failed to get response\", e);\n        this.setState({\n          awaitingResponse: false,\n          calling: false,\n        })\n        return;\n      }\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n\n    this.setState({\n      awaitingResponse: false,\n      calling: false,\n    })\n\n    this.hangUp();\n  }\n\n  hangUp() {\n    if (this.state.calling) {\n      this.webrtc.close();\n      this.webrtc = null;\n      this.localVideoRef.current.pause();\n      this.setState({\n        calling: false,\n      })\n    }\n  }\n\n  async localCall() {\n    const local = new WebRTC();\n    const remote = new WebRTC();\n\n    local.addOnTrackListener((e) => console.log(\"local\", e));\n    remote.addOnTrackListener((e) => {\n      console.log(\"remote\", e);\n      if (this.remoteVideoRef.current.srcObject !== e.streams[0]) {\n        this.remoteVideoRef.current.srcObject = e.streams[0];\n        this.remoteVideoRef.current.play();\n      }\n    });\n\n    const stream = await navigator.mediaDevices.getUserMedia(MediaConstraints);\n    this.localVideoRef.current.srcObject = stream;\n    this.localVideoRef.current.play();\n\n    local.addStream(stream);\n\n    const offer = await local.createOffer();\n    console.log(offer);\n    const answer = await remote.createAnswer(offer);\n    console.log(answer);\n\n    await local.onAnswer(answer);\n  }\n\n  render() {\n    const content = !this.state.connected ? (\n        <div>Connecting... <span className=\"spinner-grow spinner-grow-sm\" role=\"status\" aria-hidden=\"true\"></span></div>\n    ) : (this.state.signedIn ? (\n        <div>\n          <h3>Hello, {this.state.accountId}</h3>\n          <div className=\"form-group\">\n            <label className=\"sr-only\" htmlFor=\"toAccountId\">Video Call</label>\n            <div className=\"input-group\">\n              <div className=\"input-group-prepend\">\n                <div className=\"input-group-text\">@</div>\n              </div>\n              <input type=\"text\"\n                     className={this.receiverClass()}\n                     id=\"toAccountId\"\n                     placeholder=\"eugenethedream\"\n                     disabled={this.state.calling}\n                     value={this.state.receiverId}\n                     onChange={(e) => this.handleChange('receiverId', e.target.value)}\n              />\n            </div>\n          </div>\n          <div className=\"form-group\">\n            <div>\n              <button\n                  className=\"btn btn-success\"\n                  disabled={this.state.calling || !this.isValidAccount(this.state.receiverId) || !this.state.receiversKey}\n                  onClick={() => this.initCall()}>Initiate Video Call</button>\n              <span> </span>\n              <button\n                  className=\"btn btn-danger\"\n                  disabled={!this.state.calling}\n                  onClick={() => this.hangUp()}>Hang up</button>\n            </div>\n          </div>\n          <hr/>\n          <video className=\"local-video\" ref={this.localVideoRef} playsInline muted></video>\n          <video className=\"remote-video\" ref={this.remoteVideoRef} playsInline ></video>\n        </div>\n    ) : (\n        <div>\n          <button\n              className=\"btn btn-primary\"\n              onClick={() => this.requestSignIn()}>Log in with NEAR Wallet</button>\n        </div>\n    ));\n    return (\n        <div>\n          <h1>WebRTC Chat</h1>\n          {content}\n        </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}